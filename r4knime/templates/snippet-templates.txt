########################################################################################
# name: Reshape to long format
# category: utils

Creates a table with a single measurement column and several id columns.

######

library(reshape)
rOut <- melt(kIn)




########################################################################################
# name: Create column name table from selection
# category: utils

Creates a table with a single colum that contains the selected colum names.

######

<rgg>

<!--1. Title and short description -->

<h3 text="$$$TEMPLATE_NAME$$$" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">$$$TEMPLATE_DESC$$$</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

# 1. Parameter selection

<group>
# 1) select the columns
featSelection = match(c(<panellistbox label="Column selection" items="$$$PARNAMES$$$" visible-row-count="6" span="full"/>), names(kIn));

</group>


<![CDATA[

rOut <- as.data.frame(c(names(kIn)[featSelection]));
names(rOut) <- 'Column Headers';

]]>

</rgg>




########################################################################################
# name: Mahalanobis Distance Calculator
# category: screenmining

Calculates mahalonobis distances to the mean of a control group (typically your negative controls).

######

<rgg>

<!--1. Title and short description -->

<h3 text="$$$TEMPLATE_NAME$$$" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">$$$TEMPLATE_DESC$$$</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

# 1. Parameter selection

<group>
# 1) select the readouts that span the phenotypic space
featSelection = match(c(<panellistbox label="Features of interest" items="$$$NUM_ATTRIBUTES$$$" visible-row-count="6" span="full"/>), names(kIn));


# 2) calculate mean and covariance of the negative controls
negCtrls = subset(kIn, treatment == <combobox items="$$$DOMAIN('treatment')$$$" label="Negative Control"/>);

</group>


<![CDATA[

nc = negCtrls[,featSelection];
ncCov = cov(na.omit(array(nc)));
ncMean = mean(nc, na.rm=TRUE);

# append the distance as additional column
kIn$mahadist <- mahalanobis(array(kIn[featSelection]), ncMean, ncCov);

rOut <- kIn;

]]>

</rgg>




########################################################################################
# name: Box Cox Power Transform
# category: screenmining

Applies a Box-Cox power transormation to make non-normal as normal as possible.

######

<rgg>

<!--1. Title and short description -->

<h3 text="$$$TEMPLATE_NAME$$$" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">$$$TEMPLATE_DESC$$$</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

# 1. Parameter selection

<group>
# 1) select the readouts that span the phenotypic space
featSelection = match(c(<panellistbox label="Features to normalize" items="$$$NUM_ATTRIBUTES$$$" visible-row-count="6" span="full"/>), names(kIn));


</group>


<![CDATA[

#load the necessary libraries
library(car)
library(alr3)

subframe <- kIn[, featSelection];

#ensure that all values are strictly positive
subframe <- subframe - min(subframe) +0.01;


# calculate the optimal lambda for the trafo
powers <- box.cox.powers(as.matrix(subframe));

# apply the trafo
normValues <- powtran(subframe, powers$lambda, family="box.cox")

# #debug plots
# par(mfrow=c(length(subframe),1))
# sapply(1:length(subframe), FUN = function(param) { hist(normValues[, param], n=100);} )


# add a suffix to the name of the bxcx normalized columns
bxCxNames <- paste(names(subframe), '.boxcox', sep = "");
names(normValues) <- bxCxNames;

# bind both dataframes together
rOut <- cbind(kIn, normValues);

]]>

</rgg>




########################################################################################
# name: Factorized rank transform
# author: Holger Brandl
# category: utils

Adds a new column which contains the rank of a particular item (Order Inductor) within a given group (Group by). 

######

<rgg>

<!--1. Title and short description -->

<h3 text="$$$TEMPLATE_NAME$$$" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">$$$TEMPLATE_DESC$$$</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

# 1. Parameter selection

<group>

peakIndex = which(names(kIn) == <combobox items="$$$PARNAMES$$$" label="Order inductor" selected-item="peak" span="full"/>);

groupIndex = which(names(kIn) == <combobox items="$$$STR_ATTRIBUTES$$$" label="Group by" selected-item="cell" span="full"/>);

</group>


<![CDATA[

phasedata <- kIn;

#groupIndex <- 3
#peakIndex <- 6

sort.pd <- phasedata[order(phasedata[,peakIndex]),]

groups <- levels(factor(phasedata[,groupIndex]));

# add an NA order attribute
sort.pd$facRankr <- NA;

# faclevel = groups[2]
for(faclevel in groups){
	groupRowIndices <- which(sort.pd[,groupIndex] == faclevel)

	orderAttribute <- 1:length(groupRowIndices)
	sort.pd[groupRowIndices,]$facRank <- orderAttribute;
}

#restore ordering by grouping grouping factor
rOut <- sort.pd[order(sort.pd[,groupIndex]),];

]]>

</rgg>




########################################################################################
# name: Outlier removal
# author: Felix Meyenhofer
# category: pre-processing

Calculates the outliers for each group it find in the grouping column.
A row is removed if it contains an outlier for any of the specified parameter.
The method whisker uses the "boxplot-technique" to determine outliers. The remaining data is contained in [q25%-1.5*iqr...q75% + 1.5*iqr].
The meanStd removes all the points further than 3SD from the mean. The remaining data is contained in [mean-3*SD...mean+3*SD]

######

<rgg>

<!--1. Title and short description -->

<h3 text="$$$TEMPLATE_NAME$$$" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">$$$TEMPLATE_DESC$$$</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

# 1. Parameter selection

<group>
# 1) select the readouts that span the phenotypic space
selectedColumns = match(c(<panellistbox label="Features of interest" items="$$$NUM_ATTRIBUTES$$$" visible-row-count="6" span="full"/>), names(kIn));

# 2) calculate mean and covariance of the negative controls
groupingColumn = match(c(<combobox label="Grouping colum" items="$$$STR_ATTRIBUTES$$$" />), names(kIn));

# 3) calculate mean and covariance of the negative controls
method = c(<combobox items="whisker, meanSD" label="Outlier removal method"/>);

</group>


<![CDATA[

# Get the groups
groups = unique(kIn[,groupingColumn])

for (g in 1:length(groups)) {

	# Get the measurements from a specific group
	tableSubset <- subset(kIn, kIn[,groupingColumn]==groups[g])
	subsetKeeper <- rep(TRUE, each=nrow(tableSubset))

	for (c in 1:length(selectedColumns)) {

			# Get the column vector from the group
			columnSubset <- tableSubset[, selectedColumns[c]]

	 		# Determine the bounds
	 		if (method == "whisker") {
	 			outpout <- boxplot.stats(columnSubset)
				boxInfo <- outpout[[1]]
				lowerBound <- boxInfo[[1]]
				upperBound <- boxInfo[[5]]
		 	} else if (method == "meanSD") {
		 		std <- sd(columnSubset)
		 		mue <- mean(columnSubset)
		 		lowerBound <- mue - 3*std
		 		upperBound <- mue + 3*std
		 	}

	 	# Check the data points if there inside the outlier boundaries
	 	subsetKeeper <- subsetKeeper & (lowerBound <= columnSubset) & (columnSubset <= upperBound)
	 }

	 if (g == 1) {
	 	tableKeeper <- subsetKeeper
	 } else {
	 	tableKeeper <- c(tableKeeper, subsetKeeper)
	 }

}

rOut = subset(kIn, tableKeeper)

]]>

</rgg>