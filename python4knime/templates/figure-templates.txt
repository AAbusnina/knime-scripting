########################################################################################
# name: Stream plot
# author: Felix Meyenhofer (python script from Anand Patil, Steam plot method by Lee Bryon)
# category: experimental
# preview: stream-plot.png

Creates a stream plot (stacked histogram) from several input parameter

Inputs:
1) Features of interest: choose parameters to form the stream plot (stacked histogram)
2) Number of bins: binning of the data
3) Color chooser: method to pick the colors for the different parameter

######

<rgg>

<!--1. Title and short description -->

<h3 text="Steam graph" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">Generate a steam graph</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

# 1. Parameter selection
<group>
# 1) select the readouts that span the phenotypic space
keys = <panellistbox label="Features of interest" items="$$$NUM_ATTRIBUTES$$$" visible-row-count="6" span="full"/>
Nbins = int(<textfield label="Number of bins" var="" data-type="number" default-value= "30" size="10" span="full"/>)
colorSequence = <combobox items="random,linear" label="color chooser"/>
</group>


# Script
<![CDATA[

import matplotlib.pyplot as pl
import numpy as np

def symmetric(sorted_streams, stream_bounds):
   """Symmetric baseline"""
   lb, ub = np.min(stream_bounds[:,0,:],axis=0), np.max(stream_bounds[:,1,:],axis=0)
   return .5*(lb+ub)
def pos_only(sorted_streams, stream_bounds):
   """Lumps will only be positive"""
   lb, ub = np.min(stream_bounds[:,0,:],axis=0), np.max(stream_bounds[:,1,:],axis=0)
   return lb
def zero(sorted_streams, stream_bounds):
   """Zero baseline"""
   return np.zeros(stream_bounds.shape[2])
def min_weighted_wiggles(sorted_streams, stream_bounds):
   """Baseline recommended by Byron and Wattenberg"""
   lb, ub = np.min(stream_bounds[:,0,:],axis=0), np.max(stream_bounds[:,1,:],axis=0)
   weight = ub-lb

   sorted_streams = np.abs(sorted_streams)
   for i in xrange(len(sorted_streams)):
       sorted_streams[i,:] *= (-1)**i
   cusum_f = np.vstack((np.zeros(sorted_streams.shape[1]),
                       np.cumsum(sorted_streams[:-1,:], axis=0)))
   f_prime = np.diff(sorted_streams, axis=1)
   cusum_f_prime = np.diff(cusum_f, axis=1)
   g_prime = np.hstack(([0],-np.sum((f_prime*.5  + cusum_f_prime)*sorted_streams[:,1:],axis=0) / weight[1:]))
   g_prime[np.where(weight==0)] = 0
   g = np.cumsum(g_prime)

   return g


def stacked_graph(streams, cmap=pl.cm.bone, color_seq='linear', baseline_fn=min_weighted_wiggles):
   """
   Produces stacked graphs using matplotlib.

   Reference: 'Stacked graphs- geometry & aesthetics' by Byron and Wattenberg
   http://www.leebyron.com/else/streamgraph/download.php?file=stackedgraphs_byron_wattenberg.pdf

   Parameters:
     - streams: A list of time-series of positive values. Each element must be of the same length.
     - cmap: A matplotlib color map. Defaults to 'bone'.
     - colo_seq: 'linear' or 'random'.
     - baseline_fn: Current options are symmetric, pos_only, zero and min_weighted_wiggles.
   """
   # Sort by onset times
   onset_times = [np.where(np.abs(stream)>0)[0][0] for stream in streams]
   order = np.argsort(onset_times)
   streams = np.asarray(streams)
   sorted_streams = streams[order]

   t = np.arange(streams.shape[1])

   # Establish bounds
   stream_bounds = [np.vstack((np.zeros(streams.shape[1]), sorted_streams[0])),
                   np.vstack((-sorted_streams[1], (np.zeros(streams.shape[1]))))]
   side = -1
   for stream in sorted_streams[2:]:
       side *= -1
       if side==1:
           stream_bounds.append(np.vstack((stream_bounds[-2][1], stream_bounds[-2][1]+stream)))
       else:
           stream_bounds.append(np.vstack((stream_bounds[-2][0]-stream, stream_bounds[-2][0])))

   stream_bounds = np.array(stream_bounds)

   # Compute baseline
   baseline = baseline_fn(sorted_streams, stream_bounds)

   # Choose colors
   t_poly = np.hstack((t,t[::-1]))
   if color_seq=='linear':
       colors = np.linspace(0,1,streams.shape[1])
   elif color_seq=='random':
       colors = np.random.random(size=streams.shape[1])
   else:
       raise ValueError, 'Color sequence %s unrecognized'%color_seq

   # Plot
   pl.axis('off')
   for i in xrange(len(stream_bounds)):
       bound = stream_bounds[i]
       color = cmap(colors[i])
       pl.fill(t_poly, np.hstack((bound[0]-baseline,(bound[1]-baseline)[::-1])), facecolor=color, linewidth=0.,edgecolor='none')


# Demo
if __name__ == '__main__':
    v = []
    for key in keys:
        v.extend(kIn[key])
    mi = min(v)
    ma = max(v)
    dsets = []
    for key in keys:
        c,s,trash = pl.hist(kIn[key], Nbins, range=(mi, ma))
        dsets.append(c)
    pl.clf()
    stacked_graph(dsets, baseline_fn=symmetric, color_seq=colorSequence)
    pl.show()

]]>

</rgg>




########################################################################################
# name: estimate gaussian intersection
# author: Felix Meyenhofer
# category: univariate
# preview: gaussian-intersection.png

compute the histograms of random variables, fit a gaussian and compute the intersection points.
This version can only deal with TWO groups. Make sure there are no more and no less to be found in the "Grouping column".

Inputs:
1) Features of interest: choose parameters to form the stream plot (stacked histogram)
2) Number of bins: binning of the data
3) Color chooser: method to pick the colors for the different parameter

######

<rgg>

<!--1. Title and short description -->

<h3 text="Steam graph" aligment="center" span="full"/>
<separator label="Description" span="full"/>
<labelarea span="full">Generate a steam graph</labelarea>
<gaprow height="1"/>


<!-- 2. Configuration-->

<separator label="Options" span="full"/>
<gaprow height="2"/>

<group>
# a) Define your treatments of interest
strColName = <combobox label="Grouping column" items="$$$STR_ATTRIBUTES$$$" span="full"/>

# b) Define what numerical values to use
numColName = <combobox label="Numerical values" items="$$$NUM_ATTRIBUTES$$$" span="full"/>

# c) number of bins.
nBins = int(<textfield label="Number of bins" var="" data-type="number" default-value= "30" size="10" span="full"/>)

</group>


<!-- 3. Script-->
<![CDATA[

import numpy as np
from scipy import optimize, integrate
from matplotlib import pyplot
from scipy.optimize import fsolve


# Objective function to solve intersection
def fun(xy, f1, f2):
    x, y = xy
    z = np.array([y - f1(x), y - f2(x)])
    return z


def findIntersection(vect1, vect2):

    # make the histogram
    y1,x1,trash = pyplot.hist(vect1, bins=nBins, normed=True, alpha=0.5, edgecolor='none')
    y2,x2,trash = pyplot.hist(vect2, bins=nBins, normed=True, alpha=0.5, edgecolor='none')

    # calculate the center of the bins
    x1 = np.mean(np.column_stack((x1[:-1], x1[1:])).T,0)
    x2 = np.mean(np.column_stack((x2[:-1], x2[1:])).T,0)

    # estimate the parameter of the gaussian function
    mue1 = sum(x1*y1)/sum(y1)
    sig1 = np.sqrt(abs(sum((x1-mue1)**2*y1)/sum(y1)))
    a1 = y1.max()
    mue2 = sum(x2*y2)/sum(y2)
    sig2 = np.sqrt(abs(sum((x2-mue1)**2*y2)/sum(y2)))
    a2 = y2.max()

    # Fit
    fitfunc = lambda p, x: p[0]*np.exp(-(x-p[1])**2/(2*p[2]**2))       # Target function
    errfunc = lambda p, x, y: fitfunc(p, x) - y                     # Distance to the target function

    p0 = [a1, mue1, sig1]
    p1, success = optimize.leastsq(errfunc, p0[:], args=(x1, y1))
    g1 = lambda x : p1[0]*np.exp(-(x-p1[1])**2/(2*p1[2]**2))

    p0 = [a2, mue2, sig2]
    p2, success = optimize.leastsq(errfunc, p0[:], args=(x2, y2))
    g2 = lambda x : p2[0]*np.exp(-(x-p2[1])**2/(2*p2[2]**2))


    # Find the instersection.
    x0 = np.mean([mue1, mue2])
    y0 = g1(x0)
    intersection = fsolve(fun, [x0, y0], (g1, g2))

    # Compute overlap
    sig15 = sig1*5
    i1 = integrate.quad(g1, mue1-sig15, mue1+sig15)
    if mue1 > intersection[0]:
        o1 = integrate.quad(g1, mue1-sig15, intersection[0])
    else:
        o1 = integrate.quad(g1, intersection[0], mue1+sig15)

    sig25 = sig2*5
    i2 = integrate.quad(g2, mue1-sig25, mue1+sig25)
    if mue2 > intersection[0]:
        o2 = integrate.quad(g2, mue2-sig25, intersection[0])
    else:
        o2 = integrate.quad(g2, intersection[0], mue2+sig15)

    overlap = (o1[0] + o2[0]) / (i1[0] + i2[0])

    # plot the fitted cureves and the intersection.
    sigm = np.max([sig1, sig2])*3
    muemi = np.min([mue1, mue2])
    muema = np.max([mue1, mue2])
    x = np.linspace(muemi-sigm, muema+sigm, 100)
    pyplot.plot(x, g1(x), 'b', x, g2(x), 'g', intersection[0], intersection[1], 'r.', markersize=10)
    pyplot.title("Relative overlap = %s" % overlap)


# Main
vec = kIn[numColName]
cat = kIn[strColName]

sets = {}
for index in range(0,len(vec)-1):
    if sets.has_key(cat[index]):
        sets[cat[index]].append(vec[index])
    else:
        sets[cat[index]] = [vec[index]]

keys = sets.keys()
numSets = len(keys)
if numSets == 2:
    data = findIntersection(sets[keys[0]], sets[keys[1]])
else:
    raise Exception

]]>

</rgg>